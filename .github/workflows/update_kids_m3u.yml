name: Update Kids M3U Playlist with Fresh Tokens

on:
  workflow_dispatch:  # Manual trigger
  schedule:
    - cron: '0 */6 * * *'  # Run every 6 hours

jobs:
  update-playlist:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Install dependencies
      run: pip install requests
        
    - name: Generate and update kids playlist
      run: |
        cat > update_playlist.py << 'EOF'
        #!/usr/bin/env python3
        """
        Kids M3U Playlist Updater with Token Refresh
        Embedded in GitHub Actions workflow
        """
        
        import re
        import requests
        import json
        import os
        from urllib.parse import urljoin, urlparse
        
        # ================= CONFIG =================
        PLAYLIST_URLS = [
            "https://fakeall12398-sketch.github.io/JIO_TV/jstar.m3u",
            "https://fakeall12398-sketch.github.io/JIO_TV/sony.m3u",
            "https://freelivtv.xyz/oppu/opplex.m3u",
            "https://fakeall12398-sketch.github.io/JIO_TV/Allinone.m3u",
        ]
        
        OUTPUT_FILE = "kids.m3u"
        TIMEOUT = 15
        MAX_DEPTH = 2
        
        # Whitelist of kids channels
        WHITELIST_CHANNELS = [
            "disney channel", "disney junior", "disney international",
            "nickelodeon", "nick jr", "sonic", 
            "hungama", "super hungama",
            "sony yay", "yay",
            "cartoon network", "pogo", "boomerang",
        ]
        
        # Token refresh configuration (update these with your actual endpoints)
        TOKEN_CONFIG = {
            "jio": {
                "url": os.getenv('JIO_TOKEN_URL', 'https://jiotv.com/api/token/refresh'),
                "payload": {
                    "refresh_token": os.getenv('JIO_REFRESH_TOKEN', 'your_refresh_token'),
                    "device_id": os.getenv('JIO_DEVICE_ID', 'your_device_id')
                }
            },
            "sony": {
                "url": os.getenv('SONY_TOKEN_URL', 'https://sonyliv.com/api/v1/token'),
                "headers": {
                    "Authorization": f"Bearer {os.getenv('SONY_AUTH_TOKEN', 'your_auth_token')}"
                }
            }
        }
        
        # Regex patterns
        EXTINF_TITLE_RE = re.compile(r'#EXTINF:[^\n]*,(.*)', flags=re.IGNORECASE)
        LICENSE_KEY_RE = re.compile(r'license_key\s*=\s*["\']?([^"\'\s]+)["\']?', flags=re.IGNORECASE)
        
        class TokenManager:
            def __init__(self):
                self.cache = {}
                
            def refresh_jio_token(self):
                """Refresh JioTV token"""
                try:
                    config = TOKEN_CONFIG["jio"]
                    headers = {
                        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
                        "Content-Type": "application/json"
                    }
                    
                    response = requests.post(
                        config["url"],
                        json=config["payload"],
                        headers=headers,
                        timeout=TIMEOUT
                    )
                    
                    if response.status_code == 200:
                        data = response.json()
                        token = data.get("access_token") or data.get("token")
                        if token:
                            self.cache["jio"] = token
                            print("✓ JioTV token refreshed successfully")
                            return token
                except Exception as e:
                    print(f"❌ JioTV token refresh failed: {e}")
                return None
            
            def refresh_sony_token(self):
                """Refresh SonyLIV token"""
                try:
                    config = TOKEN_CONFIG["sony"]
                    headers = {
                        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
                        "Content-Type": "application/json"
                    }
                    headers.update(config.get("headers", {}))
                    
                    response = requests.post(
                        config["url"],
                        headers=headers,
                        timeout=TIMEOUT
                    )
                    
                    if response.status_code == 200:
                        data = response.json()
                        token = data.get("access_token") or data.get("token")
                        if token:
                            self.cache["sony"] = token
                            print("✓ SonyLIV token refreshed successfully")
                            return token
                except Exception as e:
                    print(f"❌ SonyLIV token refresh failed: {e}")
                return None
            
            def get_fresh_license_key(self, original_key):
                """Refresh license key with current token"""
                if not original_key:
                    return original_key
                    
                try:
                    # Determine provider from license URL
                    if "jiotv" in original_key.lower() or "jio" in original_key.lower():
                        token = self.cache.get("jio") or self.refresh_jio_token()
                        if token and "token=" in original_key:
                            return re.sub(r'token=[^&]+', f'token={token}', original_key)
                    
                    elif "sony" in original_key.lower() or "sonyliv" in original_key.lower():
                        token = self.cache.get("sony") or self.refresh_sony_token()
                        if token and "token=" in original_key:
                            return re.sub(r'token=[^&]+', f'token={token}', original_key)
                            
                except Exception as e:
                    print(f"⚠️ License key refresh failed: {e}")
                
                return original_key
            
            def get_fresh_cookies(self, provider):
                """Get fresh cookies for provider"""
                try:
                    if provider == "jio":
                        token = self.cache.get("jio") or self.refresh_jio_token()
                        if token:
                            return json.dumps({
                                "Authorization": f"Bearer {token}",
                                "User-Agent": "Mozilla/5.0 (JioTV)"
                            })
                    
                    elif provider == "sony":
                        token = self.cache.get("sony") or self.refresh_sony_token()
                        if token:
                            return json.dumps({
                                "x-access-token": token,
                                "User-Agent": "Mozilla/5.0 (SonyLIV)"
                            })
                            
                except Exception as e:
                    print(f"⚠️ Cookie refresh failed for {provider}: {e}")
                
                return None
        
        def fetch_playlist(url):
            """Fetch playlist content"""
            try:
                headers = {
                    "User-Agent": "Mozilla/5.0 (KidsPlaylistUpdater)",
                    "Accept": "*/*"
                }
                response = requests.get(url, timeout=TIMEOUT, headers=headers)
                response.raise_for_status()
                return response.text
            except Exception as e:
                print(f"❌ Failed to fetch {url}: {e}")
                return None
        
        def parse_playlist(content, base_url=None):
            """Parse M3U playlist and extract entries with metadata"""
            lines = content.splitlines()
            entries = []
            i = 0
            
            while i < len(lines):
                line = lines[i].strip()
                if not line:
                    i += 1
                    continue
                
                if line.upper().startswith("#EXTINF"):
                    extinf_line = line
                    metadata = []
                    url_line = None
                    
                    # Look ahead for metadata and URL
                    j = i + 1
                    while j < len(lines):
                        next_line = lines[j].strip()
                        if not next_line:
                            j += 1
                            continue
                        
                        if next_line.startswith("#"):
                            metadata.append(next_line)
                            j += 1
                        else:
                            url_line = next_line
                            break
                    
                    if url_line:
                        if base_url and not url_line.startswith(('http://', 'https://')):
                            url_line = urljoin(base_url, url_line)
                        
                        entries.append({
                            'extinf': extinf_line,
                            'metadata': metadata,
                            'url': url_line,
                            'title': extract_title(extinf_line)
                        })
                    
                    i = j + 1 if url_line else i + 1
                else:
                    i += 1
            
            return entries
        
        def extract_title(extinf_line):
            """Extract channel title from EXTINF line"""
            match = EXTINF_TITLE_RE.search(extinf_line)
            return match.group(1).strip() if match else ""
        
        def is_kids_channel(extinf_line, title):
            """Check if channel is in kids whitelist"""
            combined_text = (extinf_line + " " + title).lower()
            return any(channel in combined_text for channel in WHITELIST_CHANNELS)
        
        def refresh_metadata(metadata, token_manager):
            """Refresh tokens in metadata lines"""
            refreshed_metadata = []
            
            for line in metadata:
                refreshed_line = line
                
                # Refresh license keys
                if "inputstream.adaptive.license_key" in line.lower():
                    match = LICENSE_KEY_RE.search(line)
                    if match:
                        old_key = match.group(1)
                        new_key = token_manager.get_fresh_license_key(old_key)
                        if new_key != old_key:
                            refreshed_line = line.replace(old_key, new_key)
                            print(f"✓ Refreshed license key for: {urlparse(old_key).netloc}")
                
                # Refresh cookies in EXTHTTP
                elif line.upper().startswith("#EXTHTTP:"):
                    cookie_json = line[9:].strip()  # Remove #EXTHTTP:
                    try:
                        cookies = json.loads(cookie_json)
                        provider = None
                        
                        if any(x in str(cookies).lower() for x in ["jiotv", "jio"]):
                            provider = "jio"
                        elif any(x in str(cookies).lower() for x in ["sony", "sonyliv"]):
                            provider = "sony"
                        
                        if provider:
                            fresh_cookies = token_manager.get_fresh_cookies(provider)
                            if fresh_cookies:
                                refreshed_line = f"#EXTHTTP: {fresh_cookies}"
                                print(f"✓ Refreshed cookies for: {provider}")
                    except:
                        pass  # Keep original if JSON parsing fails
                
                refreshed_metadata.append(refreshed_line)
            
            return refreshed_metadata
        
        def extract_kids_channels():
            """Main function to extract and refresh kids channels"""
            print("🚀 Starting kids channels extraction with token refresh...")
            
            token_manager = TokenManager()
            all_kids_channels = []
            processed_urls = set()
            
            for playlist_url in PLAYLIST_URLS:
                print(f"\n📡 Processing: {playlist_url}")
                
                content = fetch_playlist(playlist_url)
                if not content:
                    continue
                
                entries = parse_playlist(content, playlist_url)
                kids_entries = []
                
                for entry in entries:
                    if is_kids_channel(entry['extinf'], entry['title']):
                        # Refresh metadata if it's a kids channel
                        refreshed_metadata = refresh_metadata(entry['metadata'], token_manager)
                        
                        kids_entries.append({
                            'extinf': entry['extinf'],
                            'metadata': refreshed_metadata,
                            'url': entry['url'],
                            'title': entry['title']
                        })
                
                print(f"✅ Found {len(kids_entries)} kids channels")
                all_kids_channels.extend(kids_entries)
                processed_urls.add(playlist_url)
            
            # Remove duplicates by URL
            unique_channels = {}
            for channel in all_kids_channels:
                url = channel['url']
                if url not in unique_channels:
                    unique_channels[url] = channel
            
            print(f"\n🎯 Total unique kids channels: {len(unique_channels)}")
            
            # Write final playlist
            with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
                f.write("#EXTM3U\n")
                f.write("#EXT-X-VERSION:3\n")
                f.write("#EXT-X-MEDIA-SEQUENCE:0\n")
                f.write("#EXT-X-TARGETDURATION:10\n")
                f.write("# Playlist generated with token refresh\n")
                f.write(f"# Total channels: {len(unique_channels)}\n")
                f.write(f"# Generated at: {json.dumps(str(os.getenv('GITHUB_SHA', 'local')))}\n\n")
                
                for channel in unique_channels.values():
                    f.write(channel['extinf'] + '\n')
                    for meta in channel['metadata']:
                        f.write(meta + '\n')
                    f.write(channel['url'] + '\n\n')
            
            print(f"💾 Playlist saved to: {OUTPUT_FILE}")
            
            # Summary
            print("\n📊 Summary:")
            providers_refreshed = list(token_manager.cache.keys())
            if providers_refreshed:
                print(f"✓ Tokens refreshed for: {', '.join(providers_refreshed)}")
            else:
                print("ℹ️ No tokens were refreshed (check configuration)")
            
            return len(unique_channels)
        
        if __name__ == "__main__":
            channel_count = extract_kids_channels()
            print(f"\n🎉 Process completed! Found {channel_count} kids channels.")
        EOF
        
        python update_playlist.py
        
    - name: Verify generated playlist
      run: |
        echo "Generated playlist content:"
        head -20 kids.m3u
        echo "..."
        echo "Total lines: $(wc -l < kids.m3u)"
        
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add kids.m3u
        git diff --staged --quiet || (git commit -m "🔄 Auto-update kids.m3u with fresh tokens [skip ci]" && git push)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Show completion message
      run: |
        echo "✅ Kids playlist updated successfully!"
        echo "📺 Channels are ready with fresh authentication tokens"
        echo "🕒 Next auto-update in 6 hours"
