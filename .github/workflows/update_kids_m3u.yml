name: ðŸ”„ Auto Update IPTV Tokens & License Keys (Robust)

on:
  schedule:
    - cron: "0 */11 * * *"
  workflow_dispatch:

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Fetch playlists, extract tokens, and update kids.m3u
        run: |
          python - <<'PYCODE'
          import re, requests, json

          # Config
          M3U_FILE = "kids.m3u"
          PLAYLIST_URLS = [
              "https://fakeall12398-sketch.github.io/JIO_TV/jstar.m3u",
              "https://fakeall12398-sketch.github.io/JIO_TV/sony.m3u",
              "https://freelivtv.xyz/oppu/opplex.m3u",
              "https://fakeall12398-sketch.github.io/JIO_TV/Allinone.m3u"
          ]

          # Patterns
          # capture full token value (stop at &, whitespace, or closing brace/quote)
          HDNEA_PAT = re.compile(r"__hdnea__=([^&\"'\\s\\}]+)")
          HDNTL_PAT = re.compile(r"hdntl=([^&\"'\\s\\}]+)")
          # license key from #KODIPROP
          LICENSE_PAT = re.compile(r"#KODIPROP:inputstream\.adaptive\.license_key=([^\n\r]+)")
          # find JSON inside #EXTHTTP:...
          EXTHTTP_JSON_PAT = re.compile(r'#EXTHTTP:\s*(\{.*?\})', re.DOTALL)

          # helper to parse expiration timestamp from token (exp=NUMBER)
          def parse_exp(token):
              try:
                  m = re.search(r"exp=(\d+)", token)
                  if m:
                      return int(m.group(1))
              except:
                  pass
              return 0

          def valid_hdnea_token(tok):
              """Ignore placeholder tokens like exactly 'st' or too short tokens."""
              if not tok or tok.strip().lower() == "st":
                  return False
              # prefer tokens that contain 'exp=' and 'hmac=' or at least 'exp='
              if "exp=" in tok:
                  return True
              # fallback: token length threshold
              return len(tok) > 30

          def fetch_candidates():
              hdnea_candidates = []
              hdntl_candidates = []
              license_candidates = []
              for url in PLAYLIST_URLS:
                  try:
                      r = requests.get(url, timeout=20)
                      r.raise_for_status()
                      txt = r.text
                  except Exception as e:
                      print(f"[WARN] Failed fetch {url}: {e}")
                      continue

                  # 1) From #EXTHTTP JSON cookie
                  for jm in EXTHTTP_JSON_PAT.finditer(txt):
                      jstr = jm.group(1)
                      try:
                          # sometimes JSON uses single quotes or not strictly JSON -> try replace single quotes with double
                          jsafe = jstr
                          # fix unescaped single quotes by trying json.loads; fallback to crude extraction
                          data = None
                          try:
                              data = json.loads(jsafe)
                          except:
                              try:
                                  data = json.loads(jsafe.replace("'", '"'))
                              except:
                                  data = None
                          if isinstance(data, dict):
                              cookie_val = data.get("cookie") or data.get("Cookie") or ""
                              if cookie_val:
                                  m = HDNEA_PAT.search(cookie_val)
                                  if m:
                                      tok = m.group(1)
                                      if valid_hdnea_token(tok):
                                          hdnea_candidates.append((tok, parse_exp(tok)))
                          else:
                              # crude extraction in case JSON parsing failed
                              m = re.search(r"__hdnea__=([^&\"'\\s\\}]+)", jstr)
                              if m:
                                  tok = m.group(1)
                                  if valid_hdnea_token(tok):
                                      hdnea_candidates.append((tok, parse_exp(tok)))
                      except Exception as e:
                          print("[WARN] exthttp json parse failed:", e)

                  # 2) From URLs in playlist text
                  for m in HDNEA_PAT.finditer(txt):
                      tok = m.group(1)
                      if valid_hdnea_token(tok):
                          hdnea_candidates.append((tok, parse_exp(tok)))

                  for m in HDNTL_PAT.finditer(txt):
                      tok = m.group(1)
                      # hdntl may not have exp; accept if longer than small threshold
                      if tok and len(tok) > 8:
                          hdntl_candidates.append((tok, parse_exp(tok)))

                  # 3) license key
                  for m in LICENSE_PAT.finditer(txt):
                      lk = m.group(1).strip()
                      if lk:
                          license_candidates.append(lk)

              # select best token by highest exp (if any), else longest token
              def pick_best(cands):
                  if not cands:
                      return None
                  # cands: list of (token, exp)
                  cands_sorted = sorted(cands, key=lambda t: (t[1], len(t[0])), reverse=True)
                  return cands_sorted[0][0]

              hdnea = pick_best(hdnea_candidates)
              hdntl = pick_best(hdntl_candidates)
              license_key = license_candidates[0] if license_candidates else None

              print(f"[INFO] hdnea candidate count: {len(hdnea_candidates)}, chosen: {hdnea and hdnea[:60]+'...' or None}")
              print(f"[INFO] hdntl candidate count: {len(hdntl_candidates)}, chosen: {hdntl and hdntl[:60]+'...' or None}")
              print(f"[INFO] license_key found: {bool(license_key)}")
              return {"hdnea": hdnea, "hdntl": hdntl, "license_key": license_key}

          def replace_tokens_in_file(tokens):
              try:
                  with open(M3U_FILE, "r", encoding="utf-8") as f:
                      content = f.read()
              except FileNotFoundError:
                  print(f"[ERROR] {M3U_FILE} not found")
                  return False

              updated = content

              # Replace any __hdnea__=... in URLs or params
              if tokens.get("hdnea"):
                  new = tokens["hdnea"]
                  # generic __hdnea__ replacement (stops at & or whitespace or " or ' or })
                  updated = re.sub(r"__hdnea__=[^&\"'\\s\\}]+", "__hdnea__=" + new, updated)

                  # replace cookie JSON inside #EXTHTTP:{"cookie":"..."}
                  def repl_exthttp(m):
                      jstr = m.group(1)
                      try:
                          data = None
                          try:
                              data = json.loads(jstr)
                          except:
                              data = json.loads(jstr.replace("'", '"'))
                          if isinstance(data, dict) and "cookie" in data:
                              cookie_val = data["cookie"]
                              cookie_val = re.sub(r"__hdnea__=[^&\"'\\s\\}]+", "__hdnea__=" + new, cookie_val)
                              data["cookie"] = cookie_val
                              return "#EXTHTTP:" + json.dumps(data, separators=(',',':'))
                      except Exception:
                          # fallback: simple replace inside the JSON-like string
                          return '#EXTHTTP:' + re.sub(r"__hdnea__=[^&\"'\\s\\}]+", "__hdnea__=" + new, jstr)
                      return m.group(0)

                  updated = re.sub(r'#EXTHTTP:\s*(\{.*?\})', repl_exthttp, updated, flags=re.DOTALL)

                  # replace ||cookie=__hdnea__=... suffix form
                  updated = re.sub(r"\|\|cookie=__hdnea__=[^\\s]+", "||cookie=__hdnea__=" + new, updated)

              if tokens.get("hdntl"):
                  new_hdntl = tokens["hdntl"]
                  updated = re.sub(r"hdntl=[^&\"'\\s\\}]+", "hdntl=" + new_hdntl, updated)

              if tokens.get("license_key"):
                  lk = tokens["license_key"]
                  updated = re.sub(r"(#KODIPROP:inputstream\.adaptive\.license_key=)[^\n\r]+", r"\1" + lk, updated)

              # write back always (force update)
              with open(M3U_FILE, "w", encoding="utf-8") as f:
                  f.write(updated)

              print("[INFO] Wrote updated file.")
              return True

          tokens = fetch_candidates()
          if not any(tokens.values()):
              print("[ERROR] No tokens found in any playlist; aborting.")
              exit(1)

          ok = replace_tokens_in_file(tokens)
          if not ok:
              print("[ERROR] Failed to update file.")
              exit(1)

          print("[INFO] Done - tokens updated.")
          PYCODE

      - name: Commit & push
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          DATE="$(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          git add kids.m3u
          git commit -m "ðŸ”„ Auto refresh kids.m3u tokens [${DATE}]" || echo "No changes to commit"
          git push || echo "Push failed"
